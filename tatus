[1mdiff --git a/include/shared.h b/include/shared.h[m
[1mindex b3f6951..877a829 100644[m
[1m--- a/include/shared.h[m
[1m+++ b/include/shared.h[m
[36m@@ -6,7 +6,7 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/05/14 14:24:32 by lfiorell@st       #+#    #+#             */[m
[31m-/*   Updated: 2025/07/17 16:16:55 by jfranc           ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:42:13 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[36m@@ -116,7 +116,8 @@[m [mvoid					ft_cleanup_cmd(t_cmd *cmd);[m
 int						ft_nbrofcmds(t_cmd *cmd);[m
 [m
 // pipex/ft_builtin.c[m
[31m-void					is_builtin(t_cmd **cmd, t_list **env, int cmd_idx, t_reader *exit);[m
[32m+[m[32mvoid					is_builtin(t_cmd **cmd, t_list **env, int idx,[m
[32m+[m							[32mt_reader *e);[m
 [m
 // base_commands/(...).c[m
 void					ft_cd(char **argv, t_list **envp);[m
[1mdiff --git a/src/base_commands/cd.c b/src/base_commands/cd.c[m
[1mindex 386522f..06612aa 100644[m
[1m--- a/src/base_commands/cd.c[m
[1m+++ b/src/base_commands/cd.c[m
[36m@@ -6,7 +6,7 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/07/07 17:21:40 by jfranc            #+#    #+#             */[m
[31m-/*   Updated: 2025/07/18 12:25:19 by lfiorell@st      ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:35:44 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[36m@@ -80,6 +80,18 @@[m [mstatic void	cd_go_previous(t_list **envp)[m
 	free(oldpwd_env);[m
 }[m
 [m
[32m+[m[32mvoid	cd_go_to_path(char *path, t_list **envp)[m
[32m+[m[32m{[m
[32m+[m	[32mif (chdir(argv[1]) != 0)[m
[32m+[m	[32m{[m
[32m+[m		[32mwrite(1, "cd: no such file or directory: ", 31);[m
[32m+[m		[32mwrite(1, argv[1], ft_strlen(argv[1]));[m
[32m+[m		[32mwrite(1, "\n", 1);[m
[32m+[m		[32mg_status_code = 1;[m
[32m+[m		[32mreturn ;[m
[32m+[m	[32m}[m
[32m+[m[32m}[m
[32m+[m
 void	ft_cd(char **argv, t_list **envp)[m
 {[m
 	char	cwd[PATH_MAX];[m
[36m@@ -89,16 +101,7 @@[m [mvoid	ft_cd(char **argv, t_list **envp)[m
 	else if (ft_strncmp(argv[1], "-", 2) == 0)[m
 		cd_go_previous(envp);[m
 	else[m
[31m-	{[m
[31m-		if (chdir(argv[1]) != 0)[m
[31m-		{[m
[31m-			write(1, "cd: no such file or directory: ", 31);[m
[31m-			write(1, argv[1], ft_strlen(argv[1]));[m
[31m-			write(1, "\n", 1);[m
[31m-			g_status_code = 1;[m
[31m-			return ;[m
[31m-		}[m
[31m-	}[m
[32m+[m		[32mcd_go_to_path(argv[1], envp);[m
 	set_oldpwd(envp);[m
 	if (getcwd(cwd, sizeof(cwd)) != NULL)[m
 	{[m
[1mdiff --git a/src/base_commands/echo.c b/src/base_commands/echo.c[m
[1mindex 8599a18..69000f8 100644[m
[1m--- a/src/base_commands/echo.c[m
[1m+++ b/src/base_commands/echo.c[m
[36m@@ -3,10 +3,10 @@[m
 /*                                                        :::      ::::::::   */[m
 /*   echo.c                                             :+:      :+:    :+:   */[m
 /*                                                    +:+ +:+         +:+     */[m
[31m-/*   By: jfranc <jfranc@student.42nice.fr>          +#+  +:+       +#+        */[m
[32m+[m[32m/*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/07/09 10:58:57 by jfranc            #+#    #+#             */[m
[31m-/*   Updated: 2025/07/09 11:13:29 by jfranc           ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:35:54 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[36m@@ -16,37 +16,45 @@[m
 #include <string.h>[m
 #include <unistd.h>[m
 [m
[31m-static void ft_echo_screen(int argc, char **argv, int newline, int iter) {[m
[31m-  while (iter < argc) {[m
[31m-    write(1, argv[iter], ft_strlen(argv[iter]));[m
[31m-    iter++;[m
[31m-    if (iter < argc)[m
[31m-      write(1, " ", 1);[m
[31m-    else if (newline)[m
[31m-      write(1, "\n", 1);[m
[31m-  }[m
[31m-  g_status_code = 0;[m
[32m+[m[32mstatic void	ft_echo_screen(int argc, char **argv, int newline, int iter)[m
[32m+[m[32m{[m
[32m+[m	[32mwhile (iter < argc)[m
[32m+[m	[32m{[m
[32m+[m		[32mwrite(1, argv[iter], ft_strlen(argv[iter]));[m
[32m+[m		[32miter++;[m
[32m+[m		[32mif (iter < argc)[m
[32m+[m			[32mwrite(1, " ", 1);[m
[32m+[m		[32melse if (newline)[m
[32m+[m			[32mwrite(1, "\n", 1);[m
[32m+[m	[32m}[m
[32m+[m	[32mg_status_code = 0;[m
 }[m
 [m
[31m-void ft_echo(int argc, char **argv) {[m
[31m-  int iter;[m
[31m-  int iter_s;[m
[31m-  char newline;[m
[32m+[m[32mvoid	ft_echo(int argc, char **argv)[m
[32m+[m[32m{[m
[32m+[m	[32mint		iter;[m
[32m+[m	[32mint		iter_s;[m
[32m+[m	[32mchar	newline;[m
 [m
[31m-  newline = 1;[m
[31m-  iter = 1;[m
[31m-  while (iter < argc) {[m
[31m-    iter_s = 2;[m
[31m-    if (!ft_strncmp(argv[iter], "-n", 2)) {[m
[31m-      while (argv[iter][iter_s] == 'n')[m
[31m-        iter_s++;[m
[31m-      if (!argv[iter][iter_s]) {[m
[31m-        newline = 0;[m
[31m-        iter++;[m
[31m-      } else[m
[31m-        break;[m
[31m-    } else[m
[31m-      break;[m
[31m-  }[m
[31m-  ft_echo_screen(argc, argv, newline, iter);[m
[32m+[m	[32mnewline = 1;[m
[32m+[m	[32miter = 1;[m
[32m+[m	[32mwhile (iter < argc)[m
[32m+[m	[32m{[m
[32m+[m		[32miter_s = 2;[m
[32m+[m		[32mif (!ft_strncmp(argv[iter], "-n", 2))[m
[32m+[m		[32m{[m
[32m+[m			[32mwhile (argv[iter][iter_s] == 'n')[m
[32m+[m				[32miter_s++;[m
[32m+[m			[32mif (!argv[iter][iter_s])[m
[32m+[m			[32m{[m
[32m+[m				[32mnewline = 0;[m
[32m+[m				[32miter++;[m
[32m+[m			[32m}[m
[32m+[m			[32melse[m
[32m+[m				[32mbreak ;[m
[32m+[m		[32m}[m
[32m+[m		[32melse[m
[32m+[m			[32mbreak ;[m
[32m+[m	[32m}[m
[32m+[m	[32mft_echo_screen(argc, argv, newline, iter);[m
 }[m
[1mdiff --git a/src/parser/get_redirect_token.c b/src/parser/get_redirect_token.c[m
[1mindex fb70831..be17c7c 100644[m
[1m--- a/src/parser/get_redirect_token.c[m
[1m+++ b/src/parser/get_redirect_token.c[m
[36m@@ -6,7 +6,7 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/07/16 16:40:00 by lfiorell@st       #+#    #+#             */[m
[31m-/*   Updated: 2025/07/18 12:52:38 by lfiorell@st      ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:41:18 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[36m@@ -14,10 +14,23 @@[m
 #include "shared.h"[m
 #include <errno.h>[m
 [m
[32m+[m[32m/// @brief Checks if the current token is TOKEN_NONE and retrieves[m
[32m+[m[32m/// the next token.[m
[32m+[m[32m/// @param parser The parser instance.[m
[32m+[m[32m/// @return True if the current token is TOKEN_NONE and the next token exists,[m
[32m+[m[32m///	false otherwise.[m
[32m+[m[32mstatic inline bool	is_token_none_and_next_exists(t_parser *parser)[m
[32m+[m[32m{[m
[32m+[m	[32mreturn (parser->current_token->type == TOKEN_NONE[m
[32m+[m		[32m&& (t_token *)ft_lstget(parser->token_list, parser->current_index++,[m
[32m+[m			[32mparser->token_count));[m
[32m+[m[32m}[m
[32m+[m
 /// @brief Retrieves the token that should be used as the target for a[m
[31m-/// redirection. This is typically the token immediately following a redirection[m
[31m-/// operator. It handles cases where the next token is a word or if there's a[m
[31m-/// TOKEN_NONE in between. Sets parser error if a valid target is not found.[m
[32m+[m[32m/// redirection. This is typically the token immediately following a[m
[32m+[m[32m/// redirection operator. It handles cases where the next token is a[m
[32m+[m[32m/// word or if there's a TOKEN_NONE in between. Sets parser error if[m
[32m+[m[32m/// a valid target is not found.[m
 /// @param parser The parser instance.[m
 /// @return A pointer to the redirection target token,[m
 ///          or NULL if an error occurs or no valid token is found.[m
[36m@@ -30,13 +43,10 @@[m [mt_token	*get_redirect_token(t_parser *parser)[m
 	{[m
 		token = parser->current_token;[m
 	}[m
[31m-	else if (parser->current_token->type == TOKEN_NONE[m
[31m-		&& (t_token *)ft_lstget(parser->token_list, parser->current_index++,[m
[31m-			parser->token_count))[m
[32m+[m	[32melse if (is_token_none_and_next_exists(parser))[m
 	{[m
 		token = (t_token *)ft_lstget(parser->token_list, parser->current_index,[m
 				parser->token_count);[m
[31m-		// Validate that the next token is actually a word token[m
 		if (token && token->type != TOKEN_WORD)[m
 		{[m
 			errno = EINVAL;[m
[1mdiff --git a/src/parser/parser_parse.c b/src/parser/parser_parse.c[m
[1mindex 65386c2..a099f87 100644[m
[1m--- a/src/parser/parser_parse.c[m
[1m+++ b/src/parser/parser_parse.c[m
[36m@@ -6,7 +6,7 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/06/09 10:25:58 by lfiorell@st       #+#    #+#             */[m
[31m-/*   Updated: 2025/07/18 13:58:47 by lfiorell@st      ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:38:57 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[36m@@ -24,6 +24,25 @@[m
 //   continue until it finds a token that is not a word or none.[m
 // -  special tokens like redirections should be handled accordingly.[m
 [m
[32m+[m[32mstatic void	handle_special_token(t_parser *parser)[m
[32m+[m[32m{[m
[32m+[m	[32mif (parser->last_token_type == TOKEN_PIPE)[m
[32m+[m		[32mparser_special_pipe(parser);[m
[32m+[m	[32melse if (parser->last_token_type == TOKEN_REDIRECT_IN)[m
[32m+[m		[32mparser_special_redirect_in(parser);[m
[32m+[m	[32melse if (parser->last_token_type == TOKEN_REDIRECT_OUT)[m
[32m+[m		[32mparser_special_redirect_out(parser);[m
[32m+[m	[32melse if (parser->last_token_type == TOKEN_REDIRECT_APPEND)[m
[32m+[m		[32mparser_special_redirect_append(parser);[m
[32m+[m	[32melse if (parser->last_token_type == TOKEN_REDIRECT_HEREDOC)[m
[32m+[m		[32mparser_special_redirect_heredoc(parser);[m
[32m+[m	[32melse[m
[32m+[m	[32m{[m
[32m+[m		[32merrno = EINVAL;[m
[32m+[m		[32mparser->error = PARSING_ERROR_MALLOC;[m
[32m+[m	[32m}[m
[32m+[m[32m}[m
[32m+[m
 /// @brief Handles various special tokens (pipe,[m
 ///         redirections) based on the `last_token_type`.[m
 /// It calls the appropriate specific handler for the encountered special token.[m
[36m@@ -46,24 +65,12 @@[m [mvoid	parser_handle_special(t_parser *parser)[m
 		parser->error = PARSING_MISSING_SPECIAL_TARGET;[m
 		return ;[m
 	}[m
[31m-	if (parser->last_token_type == TOKEN_PIPE)[m
[31m-		parser_special_pipe(parser);[m
[31m-	else if (parser->last_token_type == TOKEN_REDIRECT_IN)[m
[31m-		parser_special_redirect_in(parser);[m
[31m-	else if (parser->last_token_type == TOKEN_REDIRECT_OUT)[m
[31m-		parser_special_redirect_out(parser);[m
[31m-	else if (parser->last_token_type == TOKEN_REDIRECT_APPEND)[m
[31m-		parser_special_redirect_append(parser);[m
[31m-	else if (parser->last_token_type == TOKEN_REDIRECT_HEREDOC)[m
[31m-		parser_special_redirect_heredoc(parser);[m
[31m-	else[m
[32m+[m	[32mhandle_special_token(parser);[m
[32m+[m	[32mif (parser->error == PARSING_NO_ERROR)[m
 	{[m
[31m-		errno = EINVAL;[m
[31m-		parser->error = PARSING_ERROR_MALLOC;[m
[31m-		return ;[m
[32m+[m		[32mparser->current_index++;[m
[32m+[m		[32mparser->state = PARSER_NONE;[m
 	}[m
[31m-	parser->current_index++;[m
[31m-	parser->state = PARSER_NONE;[m
 }[m
 [m
 /// @brief Executes a single step in the parsing process based on the current[m
[36m@@ -93,6 +100,21 @@[m [mt_parsing_error	parser_step(t_parser *parser)[m
 	return (parser->error);[m
 }[m
 [m
[32m+[m[32mt_parsing_error	parser_loop(t_parser *parser)[m
[32m+[m[32m{[m
[32m+[m	[32mparser->current_token = ft_lstget(parser->token_list, parser->current_index,[m
[32m+[m			[32mparser->token_count);[m
[32m+[m	[32mif (!parser->current_token)[m
[32m+[m	[32m{[m
[32m+[m		[32merrno = EINVAL;[m
[32m+[m		[32mreturn (PARSING_ERROR_MALLOC);[m
[32m+[m	[32m}[m
[32m+[m	[32mparser_step(parser);[m
[32m+[m	[32mif (parser->error != PARSING_NO_ERROR)[m
[32m+[m		[32mreturn (parser->error);[m
[32m+[m	[32mparser->last_token_type = parser->current_token->type;[m
[32m+[m[32m}[m
[32m+[m
 /// @brief Main parsing function that iterates through the token list and[m
 /// processes them. It initializes the parser state and repeatedly calls[m
 /// `parser_step` to build the command structure. It advances through the tokens[m
[36m@@ -104,6 +126,8 @@[m [mt_parsing_error	parser_step(t_parser *parser)[m
 ///          or an error code if an issue occurred.[m
 t_parsing_error	parser_parse(t_parser *parser)[m
 {[m
[32m+[m	[32mt_parsing_error	error;[m
[32m+[m
 	if (!parser || !parser->token_list)[m
 	{[m
 		errno = EINVAL;[m
[36m@@ -113,17 +137,9 @@[m [mt_parsing_error	parser_parse(t_parser *parser)[m
 	parser->current_index = 0;[m
 	while (parser->current_index < parser->token_count)[m
 	{[m
[31m-		parser->current_token = ft_lstget(parser->token_list,[m
[31m-				parser->current_index, parser->token_count);[m
[31m-		if (!parser->current_token)[m
[31m-		{[m
[31m-			errno = EINVAL;[m
[31m-			return (PARSING_ERROR_MALLOC);[m
[31m-		}[m
[31m-		parser_step(parser);[m
[31m-		if (parser->error != PARSING_NO_ERROR)[m
[31m-			return (parser->error);[m
[31m-		parser->last_token_type = parser->current_token->type;[m
[32m+[m		[32merror = parser_loop(parser);[m
[32m+[m		[32mif (error != PARSING_NO_ERROR)[m
[32m+[m			[32mreturn (error);[m
 	}[m
 	if (parser->state == PARSER_SPECIAL)[m
 	{[m
[1mdiff --git a/src/pipex/cmd_path.c b/src/pipex/cmd_path.c[m
[1mindex 8f7b0aa..00e1fec 100644[m
[1m--- a/src/pipex/cmd_path.c[m
[1m+++ b/src/pipex/cmd_path.c[m
[36m@@ -3,15 +3,15 @@[m
 /*                                                        :::      ::::::::   */[m
 /*   cmd_path.c                                         :+:      :+:    :+:   */[m
 /*                                                    +:+ +:+         +:+     */[m
[31m-/*   By: jfranc <jfranc@student.42nice.fr>          +#+  +:+       +#+        */[m
[32m+[m[32m/*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/04/07 13:21:12 by jfranc            #+#    #+#             */[m
[31m-/*   Updated: 2025/07/17 14:44:55 by jfranc           ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:35:04 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[31m-#include "shared.h"[m
 #include "pipex.h"[m
[32m+[m[32m#include "shared.h"[m
 [m
 void	ft_free_split(char **split)[m
 {[m
[36m@@ -39,7 +39,7 @@[m [mstatic char	*ft_check_direct_path(char *cmd)[m
 char	*ft_get_cmd_path(char *cmd, t_list *tenvp)[m
 {[m
 	t_path_data	pd;[m
[31m-	char **freeleak;[m
[32m+[m	[32mchar		**freeleak;[m
 [m
 	pd.full_path = NULL;[m
 	freeleak = b_getenv("PATH", tenvp);[m
[36m@@ -69,9 +69,10 @@[m [mchar	*ft_get_cmd_path(char *cmd, t_list *tenvp)[m
 int	main(int ac, char **av, char **envp)[m
 {[m
 	char	*argv[] = {"./pipex", "infile", "ls", "-l", NULL};[m
[31m-	int		k = 0;[m
[32m+[m	[32mint		k;[m
 	char	*s;[m
 [m
[32m+[m	[32mk = 0;[m
 	s = ft_get_cmd_path(argv[2], envp);[m
 	ft_printf("%s\n", s);[m
 	free(s);[m
[1mdiff --git a/src/pipex/ft_pipex.c b/src/pipex/ft_pipex.c[m
[1mindex dfccad5..24f1686 100644[m
[1m--- a/src/pipex/ft_pipex.c[m
[1m+++ b/src/pipex/ft_pipex.c[m
[36m@@ -6,7 +6,7 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/06/25 11:03:33 by jfranc            #+#    #+#             */[m
[31m-/*   Updated: 2025/07/21 14:51:41 by jfranc           ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:42:37 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[36m@@ -39,15 +39,15 @@[m [mstatic void	fd_child(t_cmd *cmd, t_list *tenvp, int cmd_idx, t_reader *exit)[m
 		printf("error fork of pid %d", cmd_idx);[m
 		closefd(cmd, EXIT_FAILURE, exit);[m
 	}[m
[31m-	if (cmd[cmd_idx].pid == 0) // Child process[m
[32m+[m	[32mif (cmd[cmd_idx].pid == 0)[m
 	{[m
 		pipe_redirection(cmd, cmd_idx);[m
 		if (ft_check_if_builtin(cmd, cmd_idx))[m
 			is_builtin(&cmd, &tenvp, cmd_idx, exit);[m
[31m-		if (cmd->error == 1) // Handle errors found before fork[m
[32m+[m		[32mif (cmd->error == 1)[m
 			closefd(cmd, EXIT_FAILURE, exit);[m
 		if (!cmd->cmdpathlist[cmd_idx])[m
[31m-			closefd(cmd, 127, exit); // Exit with status 127[m
[32m+[m			[32mclosefd(cmd, 127, exit);[m
 		execve(cmd->cmdpathlist[cmd_idx], cmd[cmd_idx].args, b_getenv(NULL,[m
 				tenvp));[m
 		perror(cmd[cmd_idx].args[0]);[m
[1mdiff --git a/src/read_input.c b/src/read_input.c[m
[1mindex 2547b28..978b7b3 100644[m
[1m--- a/src/read_input.c[m
[1m+++ b/src/read_input.c[m
[36m@@ -6,7 +6,7 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/07/16 20:00:00 by lfiorell@st       #+#    #+#             */[m
[31m-/*   Updated: 2025/07/16 20:15:21 by lfiorell@st      ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:41:52 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[36m@@ -19,19 +19,22 @@[m
 [m
 #define PROMPT "picoshell> "[m
 [m
[31m-int read_input(t_reader *reader_ptr) {[m
[31m-  print_prompt(reader_ptr->env);[m
[31m-  reader_ptr->cached_input = readline(PROMPT);[m
[31m-  if (str_is_whitespace(reader_ptr->cached_input)) {[m
[31m-    g_status_code = 0;[m
[31m-    return 2;[m
[31m-  }[m
[31m-  add_history(reader_ptr->cached_input);[m
[31m-  if (!reader_ptr->cached_input) {[m
[31m-    if (errno == EINTR)[m
[31m-      return (1);[m
[31m-    write(1, "exit\n", 5);[m
[31m-    return (0);[m
[31m-  }[m
[31m-  return (2);[m
[32m+[m[32mint	read_input(t_reader *reader_ptr)[m
[32m+[m[32m{[m
[32m+[m	[32mprint_prompt(reader_ptr->env);[m
[32m+[m	[32mreader_ptr->cached_input = readline(PROMPT);[m
[32m+[m	[32mif (str_is_whitespace(reader_ptr->cached_input))[m
[32m+[m	[32m{[m
[32m+[m		[32mg_status_code = 0;[m
[32m+[m		[32mreturn (2);[m
[32m+[m	[32m}[m
[32m+[m	[32madd_history(reader_ptr->cached_input);[m
[32m+[m	[32mif (!reader_ptr->cached_input)[m
[32m+[m	[32m{[m
[32m+[m		[32mif (errno == EINTR)[m
[32m+[m			[32mreturn (1);[m
[32m+[m		[32mwrite(1, "exit\n", 5);[m
[32m+[m		[32mreturn (0);[m
[32m+[m	[32m}[m
[32m+[m	[32mreturn (2);[m
 }[m
[1mdiff --git a/src/reader/reader_free.c b/src/reader/reader_free.c[m
[1mindex 5e6eb9c..7acdef0 100644[m
[1m--- a/src/reader/reader_free.c[m
[1m+++ b/src/reader/reader_free.c[m
[36m@@ -6,7 +6,7 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/06/16 19:34:24 by lfiorell@st       #+#    #+#             */[m
[31m-/*   Updated: 2025/07/21 14:30:26 by jfranc           ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:34:12 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[36m@@ -50,7 +50,7 @@[m [mvoid	reader_free(t_reader *reader)[m
 	{[m
 		ft_cleanup_cmd(reader->commands);[m
 		free(reader->commands);[m
[31m-		/**/reader->commands = NULL;[m
[32m+[m		[32mreader->commands = NULL;[m
 	}[m
 	if (reader->varnames)[m
 		free(reader->varnames);[m
[1mdiff --git a/src/reader/reader_init.c b/src/reader/reader_init.c[m
[1mindex 27daf76..651585d 100644[m
[1m--- a/src/reader/reader_init.c[m
[1m+++ b/src/reader/reader_init.c[m
[36m@@ -6,37 +6,58 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/06/16 19:42:35 by lfiorell@st       #+#    #+#             */[m
[31m-/*   Updated: 2025/06/17 11:23:17 by lfiorell@st      ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:34:49 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
 #include "reader.h"[m
 [m
[31m-t_reader	*reader_init(char *const *envp)[m
[32m+[m[32mstatic t_reader	*allocate_reader(void)[m
 {[m
 	t_reader	*reader;[m
 [m
 	reader = ft_calloc(1, sizeof(t_reader));[m
 	if (reader == NULL)[m
[31m-	{[m
 		errno = ENOMEM;[m
[31m-		return (NULL);[m
[31m-	}[m
[32m+[m	[32mreturn (reader);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int	initialize_env(t_reader *reader, char *const *envp)[m
[32m+[m[32m{[m
 	reader->env = b_fromenvp(envp);[m
 	if (reader->env == NULL)[m
 	{[m
 		free(reader);[m
 		errno = ENOMEM;[m
[31m-		return (NULL);[m
[32m+[m		[32mreturn (0);[m
 	}[m
[32m+[m	[32mreturn (1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstatic int	initialize_linereader(t_reader *reader)[m
[32m+[m[32m{[m
 	reader->linereader = ft_calloc(1, sizeof(t_linereader));[m
 	if (reader->linereader == NULL)[m
 	{[m
 		ft_lstclear(&reader->env, free);[m
 		free(reader);[m
 		errno = ENOMEM;[m
[31m-		return (NULL);[m
[32m+[m		[32mreturn (0);[m
 	}[m
[32m+[m	[32mreturn (1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mt_reader	*reader_init(char *const *envp)[m
[32m+[m[32m{[m
[32m+[m	[32mt_reader	*reader;[m
[32m+[m
[32m+[m	[32mreader = allocate_reader();[m
[32m+[m	[32mif (reader == NULL)[m
[32m+[m		[32mreturn (NULL);[m
[32m+[m	[32mif (!initialize_env(reader, envp))[m
[32m+[m		[32mreturn (NULL);[m
[32m+[m	[32mif (!initialize_linereader(reader))[m
[32m+[m		[32mreturn (NULL);[m
 	reader->cached_input = NULL;[m
 	reader->commands = NULL;[m
 	reader->varnames = NULL;[m
[1mdiff --git a/src/reader/try_lex.c b/src/reader/try_lex.c[m
[1mindex 6739e94..0cbb68f 100644[m
[1m--- a/src/reader/try_lex.c[m
[1m+++ b/src/reader/try_lex.c[m
[36m@@ -6,7 +6,7 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/07/16 00:00:00 by lfiorell@st       #+#    #+#             */[m
[31m-/*   Updated: 2025/07/16 14:23:48 by lfiorell@st      ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:33:49 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[36m@@ -14,27 +14,31 @@[m
 #include "reader.h"[m
 #include "varextract.h"[m
 [m
[31m-bool try_lex(t_reader *reader) {[m
[31m-  reader->lexer = create_lexer(reader->cached);[m
[31m-  if (reader->lexer == NULL) {[m
[31m-    errno = ENOMEM;[m
[31m-    return (false);[m
[31m-  }[m
[31m-  reader->tokens = run_lexer(reader->lexer);[m
[31m-  if (reader->tokens == NULL && errno == EINVAL) {[m
[31m-    ft_putstr_fd("minishell: syntax error: unclosed quote\n", 2);[m
[31m-    free_lexer(reader->lexer);[m
[31m-    reader->lexer = NULL;[m
[31m-    g_status_code = 2;[m
[31m-    return (false);[m
[31m-  }[m
[31m-  if (reader->tokens == NULL) {[m
[31m-    free_lexer(reader->lexer);[m
[31m-    reader->lexer = NULL;[m
[31m-    errno = EINVAL;[m
[31m-    return (false);[m
[31m-  }[m
[31m-  reader->vars = b_varextract(reader->lexer->token_list);[m
[31m-  join_words(reader->lexer);[m
[31m-  return (true);[m
[32m+[m[32mbool	try_lex(t_reader *reader)[m
[32m+[m[32m{[m
[32m+[m	[32mreader->lexer = create_lexer(reader->cached);[m
[32m+[m	[32mif (reader->lexer == NULL)[m
[32m+[m	[32m{[m
[32m+[m		[32merrno = ENOMEM;[m
[32m+[m		[32mreturn (false);[m
[32m+[m	[32m}[m
[32m+[m	[32mreader->tokens = run_lexer(reader->lexer);[m
[32m+[m	[32mif (reader->tokens == NULL && errno == EINVAL)[m
[32m+[m	[32m{[m
[32m+[m		[32mft_putstr_fd("minishell: syntax error: unclosed quote\n", 2);[m
[32m+[m		[32mfree_lexer(reader->lexer);[m
[32m+[m		[32mreader->lexer = NULL;[m
[32m+[m		[32mg_status_code = 2;[m
[32m+[m		[32mreturn (false);[m
[32m+[m	[32m}[m
[32m+[m	[32mif (reader->tokens == NULL)[m
[32m+[m	[32m{[m
[32m+[m		[32mfree_lexer(reader->lexer);[m
[32m+[m		[32mreader->lexer = NULL;[m
[32m+[m		[32merrno = EINVAL;[m
[32m+[m		[32mreturn (false);[m
[32m+[m	[32m}[m
[32m+[m	[32mreader->vars = b_varextract(reader->lexer->token_list);[m
[32m+[m	[32mjoin_words(reader->lexer);[m
[32m+[m	[32mreturn (true);[m
 }[m
[1mdiff --git a/src/utils/b_unsetenv.c b/src/utils/b_unsetenv.c[m
[1mindex f3f6b6c..aae3cd6 100644[m
[1m--- a/src/utils/b_unsetenv.c[m
[1m+++ b/src/utils/b_unsetenv.c[m
[36m@@ -6,79 +6,86 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/06/05 11:00:00 by lfiorell@st       #+#    #+#             */[m
[31m-/*   Updated: 2025/07/10 12:13:34 by lfiorell@st      ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:41:31 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
 #include "shared.h"[m
 #include <stdlib.h>[m
 [m
[31m-static int str_equal(const char *s1, const char *s2) {[m
[31m-  size_t len1;[m
[31m-  size_t len2;[m
[32m+[m[32mstatic int	str_equal(const char *s1, const char *s2)[m
[32m+[m[32m{[m
[32m+[m	[32msize_t	len1;[m
[32m+[m	[32msize_t	len2;[m
 [m
[31m-  if (!s1 || !s2)[m
[31m-    return (0);[m
[31m-  len1 = ft_strlen(s1);[m
[31m-  len2 = ft_strlen(s2);[m
[31m-  if (len1 != len2)[m
[31m-    return (0);[m
[31m-  return (ft_strncmp(s1, s2, len1) == 0);[m
[32m+[m	[32mif (!s1 || !s2)[m
[32m+[m		[32mreturn (0);[m
[32m+[m	[32mlen1 = ft_strlen(s1);[m
[32m+[m	[32mlen2 = ft_strlen(s2);[m
[32m+[m	[32mif (len1 != len2)[m
[32m+[m		[32mreturn (0);[m
[32m+[m	[32mreturn (ft_strncmp(s1, s2, len1) == 0);[m
 }[m
 [m
[31m-static void free_env_entry(void *content) {[m
[31m-  t_env *env;[m
[32m+[m[32mstatic void	free_env_entry(void *content)[m
[32m+[m[32m{[m
[32m+[m	[32mt_env	*env;[m
 [m
[31m-  if (!content)[m
[31m-    return;[m
[31m-  env = (t_env *)content;[m
[31m-  if (env->key)[m
[31m-    free(env->key);[m
[31m-  if (env->value)[m
[31m-    free(env->value);[m
[31m-  free(env);[m
[32m+[m	[32mif (!content)[m
[32m+[m		[32mreturn ;[m
[32m+[m	[32menv = (t_env *)content;[m
[32m+[m	[32mif (env->key)[m
[32m+[m		[32mfree(env->key);[m
[32m+[m	[32mif (env->value)[m
[32m+[m		[32mfree(env->value);[m
[32m+[m	[32mfree(env);[m
 }[m
 [m
[31m-static void remove_env_node(t_list *prev, t_list *current, t_list **envp,[m
[31m-                            void (*del)(void *)) {[m
[31m-  if (prev)[m
[31m-    prev->next = current->next;[m
[31m-  else[m
[31m-    *envp = current->next;[m
[31m-  if (del)[m
[31m-    del(current->content);[m
[31m-  else[m
[31m-    free_env_entry(current->content);[m
[31m-  free(current);[m
[32m+[m[32mstatic void	remove_env_node(t_list *prev, t_list *current, t_list **envp,[m
[32m+[m		[32mvoid (*del)(void *))[m
[32m+[m[32m{[m
[32m+[m	[32mif (prev)[m
[32m+[m		[32mprev->next = current->next;[m
[32m+[m	[32melse[m
[32m+[m		[32m*envp = current->next;[m
[32m+[m	[32mif (del)[m
[32m+[m		[32mdel(current->content);[m
[32m+[m	[32melse[m
[32m+[m		[32mfree_env_entry(current->content);[m
[32m+[m	[32mfree(current);[m
 }[m
 [m
[31m-static int is_matching_env(t_list *node, const char *key) {[m
[31m-  t_env *env_entry;[m
[32m+[m[32mstatic int	is_matching_env(t_list *node, const char *key)[m
[32m+[m[32m{[m
[32m+[m	[32mt_env	*env_entry;[m
 [m
[31m-  if (!node || !node->content)[m
[31m-    return (0);[m
[31m-  env_entry = (t_env *)node->content;[m
[31m-  if (!env_entry || !env_entry->key)[m
[31m-    return (0);[m
[31m-  return (str_equal(env_entry->key, key));[m
[32m+[m	[32mif (!node || !node->content)[m
[32m+[m		[32mreturn (0);[m
[32m+[m	[32menv_entry = (t_env *)node->content;[m
[32m+[m	[32mif (!env_entry || !env_entry->key)[m
[32m+[m		[32mreturn (0);[m
[32m+[m	[32mreturn (str_equal(env_entry->key, key));[m
 }[m
 [m
[31m-void b_unsetenv(const char *key, void (*del)(void *), t_list **envp) {[m
[31m-  t_list *current;[m
[31m-  t_list *prev;[m
[32m+[m[32mvoid	b_unsetenv(const char *key, void (*del)(void *), t_list **envp)[m
[32m+[m[32m{[m
[32m+[m	[32mt_list	*current;[m
[32m+[m	[32mt_list	*prev;[m
 [m
[31m-  if (!key || !envp || !*envp)[m
[31m-    return;[m
[31m-  if (ft_strncmp(key, "PWD", 4) == 0 || ft_strncmp(key, "OLDPWD", 7) == 0)[m
[31m-    return (b_setenv(key, getenv(key), envp));[m
[31m-  current = *envp;[m
[31m-  prev = NULL;[m
[31m-  while (current) {[m
[31m-    if (is_matching_env(current, key)) {[m
[31m-      remove_env_node(prev, current, envp, del);[m
[31m-      return;[m
[31m-    }[m
[31m-    prev = current;[m
[31m-    current = current->next;[m
[31m-  }[m
[32m+[m	[32mif (!key || !envp || !*envp)[m
[32m+[m		[32mreturn ;[m
[32m+[m	[32mif (ft_strncmp(key, "PWD", 4) == 0 || ft_strncmp(key, "OLDPWD", 7) == 0)[m
[32m+[m		[32mreturn (b_setenv(key, getenv(key), envp));[m
[32m+[m	[32mcurrent = *envp;[m
[32m+[m	[32mprev = NULL;[m
[32m+[m	[32mwhile (current)[m
[32m+[m	[32m{[m
[32m+[m		[32mif (is_matching_env(current, key))[m
[32m+[m		[32m{[m
[32m+[m			[32mremove_env_node(prev, current, envp, del);[m
[32m+[m			[32mreturn ;[m
[32m+[m		[32m}[m
[32m+[m		[32mprev = current;[m
[32m+[m		[32mcurrent = current->next;[m
[32m+[m	[32m}[m
 }[m
[1mdiff --git a/src/utils/ft_var.c b/src/utils/ft_var.c[m
[1mindex 5966844..053690e 100644[m
[1m--- a/src/utils/ft_var.c[m
[1m+++ b/src/utils/ft_var.c[m
[36m@@ -6,7 +6,7 @@[m
 /*   By: lfiorell@student.42nice.fr <lfiorell>      +#+  +:+       +#+        */[m
 /*                                                +#+#+#+#+#+   +#+           */[m
 /*   Created: 2025/07/15 11:30:08 by lfiorell@st       #+#    #+#             */[m
[31m-/*   Updated: 2025/07/16 17:02:50 by lfiorell@st      ###   ########.fr       */[m
[32m+[m[32m/*   Updated: 2025/07/22 13:41:43 by lfiorell@st      ###   ########.fr       */[m
 /*                                                                            */[m
 /* ************************************************************************** */[m
 [m
[36m@@ -24,49 +24,54 @@[m
 [m
 #define VAR_BUFFER_SIZE 128[m
 [m
[31m-size_t ft_strlen_or_something_i_do_not_know(char *str, char **varnames,[m
[31m-                                            t_list *env) {[m
[31m-  size_t len;[m
[31m-  size_t i;[m
[32m+[m[32msize_t	ft_strlen_or_something_i_do_not_know(char *str, char **varnames,[m
[32m+[m		[32mt_list *env)[m
[32m+[m[32m{[m
[32m+[m	[32msize_t	len;[m
[32m+[m	[32msize_t	i;[m
 [m
[31m-  len = 0;[m
[31m-  i = 0;[m
[31m-  while (str[i] != '\0') {[m
[31m-    if (str[i] != '$')[m
[31m-      len += handle_regular_char(&i);[m
[31m-    else[m
[31m-      len += handle_dollar_char(str, &i, varnames, env);[m
[31m-  }[m
[31m-  return (len);[m
[32m+[m	[32mlen = 0;[m
[32m+[m	[32mi = 0;[m
[32m+[m	[32mwhile (str[i] != '\0')[m
[32m+[m	[32m{[m
[32m+[m		[32mif (str[i] != '$')[m
[32m+[m			[32mlen += handle_regular_char(&i);[m
[32m+[m		[32melse[m
[32m+[m			[32mlen += handle_dollar_char(str, &i, varnames, env);[m
[32m+[m	[32m}[m
[32m+[m	[32mreturn (len);[m
 }[m
 [m
[31m-static void loopvar(t_var_context *ctx) {[m
[31m-  if (ctx->src[*(ctx->i)] != '$')[m
[31m-    ctx->k = copy_regular_char(ctx->dest, ctx->src, ctx->i, ctx->k);[m
[31m-  else[m
[31m-    ctx->k = handle_dollar_substitution(ctx);[m
[32m+[m[32mstatic void	loopvar(t_var_context *ctx)[m
[32m+[m[32m{[m
[32m+[m	[32mif (ctx->src[*(ctx->i)] != '$')[m
[32m+[m		[32mctx->k = copy_regular_char(ctx->dest, ctx->src, ctx->i, ctx->k);[m
[32m+[m	[32melse[m
[32m+[m		[32mctx->k = handle_dollar_substitution(ctx);[m
 }[m
 [m
[31m-char *ft_var(char *var, char **varnames, t_list *env) {[m
[31m-  size_t len;[m
[31m-  char *owo;[m
[31m-  size_t i;[m
[31m-  size_t k;[m
[31m-  t_var_context ctx;[m
[32m+[m[32mchar	*ft_var(char *var, char **varnames, t_list *env)[m
[32m+[m[32m{[m
[32m+[m	[32msize_t			len;[m
[32m+[m	[32mchar			*owo;[m
[32m+[m	[32msize_t			i;[m
[32m+[m	[32msize_t			k;[m
[32m+[m	[32mt_var_context	ctx;[m
 [m
[31m-  len = ft_strlen_or_something_i_do_not_know(var, varnames, env);[m
[31m-  owo = malloc(len + 1);[m
[31m-  if (!owo) {[m
[31m-    perror("malloc");[m
[31m-    return (NULL);[m
[31m-  }[m
[31m-  i = 0;[m
[31m-  k = 0;[m
[31m-  ctx = (t_var_context){owo, var, &i, k, varnames, env, len};[m
[31m-  while (var[i] != '\0')[m
[31m-    loopvar(&ctx);[m
[31m-  owo[len] = '\0';[m
[31m-  replace_backspace_with_dollar(owo);[m
[31m-  free(var);[m
[31m-  return (owo);[m
[32m+[m	[32mlen = ft_strlen_or_something_i_do_not_know(var, varnames, env);[m
[32m+[m	[32mowo = malloc(len + 1);[m
[32m+[m	[32mif (!owo)[m
[32m+[m	[32m{[m
[32m+[m		[32mperror("malloc");[m
[32m+[m		[32mreturn (NULL);[m
[32m+[m	[32m}[m
[32m+[m	[32mi = 0;[m
[32m+[m	[32mk = 0;[m
[32m+[m	[32mctx = (t_var_context){owo, var, &i, k, varnames, env, len};[m
[32m+[m	[32mwhile (var[i] != '\0')[m
[32m+[m		[32mloopvar(&ctx);[m
[32m+[m	[32mowo[len] = '\0';[m
[32m+[m	[32mreplace_backspace_with_dollar(owo);[m
[32m+[m	[32mfree(var);[m
[32m+[m	[32mreturn (owo);[m
 }[m
